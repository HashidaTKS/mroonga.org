<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>コーディングスタイル &mdash; mroonga v3.02 documentation</title>
    
    <link rel="stylesheet" href="../static/mroonga.css" type="text/css" />
    <link rel="stylesheet" href="../static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '3.02',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../static/jquery.js"></script>
    <script type="text/javascript" src="../static/underscore.js"></script>
    <script type="text/javascript" src="../static/doctools.js"></script>
    <script type="text/javascript" src="../static/translations.js"></script>
    <link rel="shortcut icon" href="../static/favicon.ico"/>
    <link rel="top" title="mroonga v3.02 documentation" href="../index.html" /> 
      <meta property="fb:page_id" content="238184682903165" /><!-- mroonga -->
    <meta property="fb:admins" content="664204556" /><!-- kouhei.sutou -->
    <meta property="og:type" content="product" />
    <meta property="og:image" content="http://mroonga.org/images/logos/mroonga-icon-full-size.png" />
    <meta property="og:site_name" content="mroonga" />

    <link rel="stylesheet" href="/css/sphinx.css" type="text/css" />
  </head>

    <body>
    <div id="fb-root"></div>

<div class="header">
  <h1 class="title">
    <a id="top-link" href="../../">
      <span class="project">mroonga</span>
      <span class="separator">-</span>
      <span class="description">MySQLで高速に全文検索するためのオープンソースのストレージエンジン</span>
    </a>
  </h1>

      <div class="facebook-buttons">
      <fb:like href="http://www.facebook.com/pages/mroonga/238184682903165"
               layout="standard"
               width="290"></fb:like>
    </div>
    <div class="other-language-links">

    <ul>
      <li><a href="../../../docs/developer/coding_style.html"><img src="../static/us.png" alt="English">English version</a></li>
    </ul>
  </div>
</div>
  

    <div class="related">
      <h3>ナビゲーション</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="総合索引"
             accesskey="I">索引</a></li>
        <li><a href="../index.html">mroonga v3.02 documentation</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <p>TODO: Translate.</p>
<div class="section" id="id1">
<h1>コーディングスタイル<a class="headerlink" href="#id1" title="このヘッドラインへのパーマリンク">¶</a></h1>
<p>一般的に1つのコードベースに複数のスタイルがまざっているとソースコードが読みづらくなります。たとえ、それぞれのスタイル単独では読みやすいスタイルあっても、まざると読みづらくなります。そのため、mroongaプロジェクトでもスタイルを統一して、読みやすいソースコードになるようにします。</p>
<p>読みやすいソースコードにする理由は以下の通りです。</p>
<blockquote>
<div><ul class="simple">
<li>機能を拡張するときのコストを下げる。</li>
<li>問題を修正するときのコストを下げる。</li>
</ul>
</div></blockquote>
<p>どちらの場合も周辺のソースコードを読んで、それをベースにコードを追加・変更します。このとき、ソースコードが読みやすい状態だと周辺のソースコードの把握をスムーズに行うことができ、スムーズにその後の作業に移れます。</p>
<p>TODO: 読みやすさの他にデバッグのしやすさ（gdbでの追いやすさ）も考慮に入れたほうがよさそうだがどうしよう。</p>
<div class="section" id="id2">
<h2>言語<a class="headerlink" href="#id2" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>基本的にすべてC++で記述します。よほどのことがない限りCは使いません。</p>
<p>よい例:</p>
<div class="highlight-none"><div class="highlight"><pre>ha_mroonga.cpp
</pre></div>
</div>
<p>悪い例（C言語を使っている）:</p>
<div class="highlight-none"><div class="highlight"><pre>mrn_sys.c
</pre></div>
</div>
</div>
<div class="section" id="id3">
<h2>ファイル名<a class="headerlink" href="#id3" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>ソースコードのファイル名は全て小文字にします。また、単語ごとに&quot;_&quot;で区切ります。</p>
<p>よい例:</p>
<div class="highlight-none"><div class="highlight"><pre>ha_mroonga.cpp
</pre></div>
</div>
<p>悪い例（大文字を使っている）:</p>
<div class="highlight-none"><div class="highlight"><pre>HA_MROONGA.cpp
</pre></div>
</div>
<p>悪い例（単語を&quot;_&quot;で区切らずにくっつけている）:</p>
<div class="highlight-none"><div class="highlight"><pre>hamroonga.cpp
</pre></div>
</div>
<p>悪い例（単語を&quot;-&quot;で区切っている）:</p>
<div class="highlight-none"><div class="highlight"><pre>ha-mroonga.cpp
</pre></div>
</div>
<p>ソースコードの拡張子 <tt class="docutils literal"><span class="pre">.cpp</span></tt> にします。</p>
<p>よい例:</p>
<div class="highlight-none"><div class="highlight"><pre>ha_mroonga.cpp
</pre></div>
</div>
<p>悪い例（ <tt class="docutils literal"><span class="pre">.cc</span></tt> を使っている）:</p>
<div class="highlight-none"><div class="highlight"><pre>ha_mroonga.cc
</pre></div>
</div>
<p>ヘッダーファイルの拡張子は <tt class="docutils literal"><span class="pre">.hpp</span></tt> にします。</p>
<p>よい例:</p>
<div class="highlight-none"><div class="highlight"><pre>ha_mroonga.hpp
</pre></div>
</div>
<p>悪い例（ <tt class="docutils literal"><span class="pre">.h</span></tt> を使っている）:</p>
<blockquote>
<div>ha_mroonga.h</div></blockquote>
</div>
<div class="section" id="id4">
<h2>名前空間<a class="headerlink" href="#id4" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>ヘッダーファイルでは <tt class="docutils literal"><span class="pre">using</span> <span class="pre">namespace</span></tt> を使わない。ソースコードでは <tt class="docutils literal"><span class="pre">using</span> <span class="pre">namespace</span> <span class="pre">std</span></tt> であれば使ってもよい。他の名前空間は使ってはいけない。</p>
<p>よい例:</p>
<div class="highlight-none"><div class="highlight"><pre>ha_mroonga.cpp:
  using namespace std;
</pre></div>
</div>
<p>悪い例（ヘッダーファイル内で <tt class="docutils literal"><span class="pre">using</span> <span class="pre">namespace</span></tt> を使っている）:</p>
<div class="highlight-none"><div class="highlight"><pre>ha_mroonga.hpp:
  using namespace std;
</pre></div>
</div>
<p>悪い例（ <tt class="docutils literal"><span class="pre">std</span></tt> 以外の名前空間に対して <tt class="docutils literal"><span class="pre">using</span> <span class="pre">namespace</span></tt> を使っている）:</p>
<div class="highlight-none"><div class="highlight"><pre>ha_mroonga.cpp:
  using namespace zmq;
</pre></div>
</div>
</div>
<div class="section" id="include">
<h2><tt class="docutils literal"><span class="pre">include</span></tt> ガード<a class="headerlink" href="#include" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>2重 <tt class="docutils literal"><span class="pre">include</span></tt> を防ぐためのマクロは、ヘッダーファイルの名前をすべて大文字にし、単語の区切りをアンダースコアにしたものにし、最後にアンダースコアをつけて <tt class="docutils literal"><span class="pre">HEADER_FILE_NAME_HPP_</span></tt> という名前にする。</p>
<p>よい例:</p>
<div class="highlight-none"><div class="highlight"><pre>mrn_db_path.hpp:
  #ifndef MRN_DB_PATH_HPP_
  #define MRN_DB_PATH_HPP_
  ...
  #endif // MRN_DB_PATH_HPP_
</pre></div>
</div>
<p>悪い例（小文字になっている）:</p>
<div class="highlight-none"><div class="highlight"><pre>mrn_db_path.hpp:
  #ifndef mrn_db_path_hpp_
  #define mrn_db_path_hpp_
  ...
  #endif // mrn_db_path_hpp_
</pre></div>
</div>
<p>悪い例（アンダースコアが最後ではなく先頭についている）:</p>
<div class="highlight-none"><div class="highlight"><pre>mrn_db_path.hpp:
  #ifndef _MRN_DB_PATH_HPP
  #define _MRN_DB_PATH_HPP
  ...
  #endif // _MRN_DB_PATH_HPP
</pre></div>
</div>
</div>
<div class="section" id="id5">
<h2>代入<a class="headerlink" href="#id5" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p><tt class="docutils literal"><span class="pre">=</span></tt> の前後に1つスペースを入れる。</p>
<p>よい例:</p>
<div class="highlight-none"><div class="highlight"><pre>int i = 0;
</pre></div>
</div>
<p>悪い例（スペースが入っていない）:</p>
<div class="highlight-none"><div class="highlight"><pre>for (i=0; i&lt;10; ++i) {...}
</pre></div>
</div>
<p>悪い例（2つスペースが入っている）:</p>
<div class="highlight-none"><div class="highlight"><pre>int i  = 0;
</pre></div>
</div>
</div>
<div class="section" id="id6">
<h2>文字列<a class="headerlink" href="#id6" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>文字列はポインタと長さで表現する。 <tt class="docutils literal"><span class="pre">\0</span></tt> での終端を仮定しない。</p>
<p>よい例（本当はもっとすっきりした例がよいけど。。。）:</p>
<div class="highlight-none"><div class="highlight"><pre>char *raw_data = &quot;table_name column_name column_value&quot;
char *column_name;
size_t column_name_size;
column_name = raw_data + strlen(&quot;table_name &quot;);
column_name_size = strlen(&quot;column_name&quot;);
</pre></div>
</div>
<p>悪い例（無理やり <tt class="docutils literal"><span class="pre">\0</span></tt> 終端にしている）:</p>
<div class="highlight-none"><div class="highlight"><pre>char *raw_data = &quot;table_name column_name column_value&quot;
char *column_name;
column_name = strndup(raw_data + strlen(&quot;table_name &quot;), strlen(&quot;column_name&quot;));
</pre></div>
</div>
<p>ただし、ファイル名など <tt class="docutils literal"><span class="pre">\0</span></tt> が前提であるものに関しては <tt class="docutils literal"><span class="pre">\0</span></tt> 終端を仮定してよい。</p>
<p>よい例:</p>
<div class="highlight-none"><div class="highlight"><pre>char *database_path = &quot;db/test.mrn&quot;;
</pre></div>
</div>
<p>悪い例（ <tt class="docutils literal"><span class="pre">\0</span></tt> 終端を仮定せず、長さも管理している）:</p>
<div class="highlight-none"><div class="highlight"><pre>char *database_path = &quot;db/test.mrn&quot;;
size_t database_path_size = strlen(&quot;db/test.mrn&quot;);
</pre></div>
</div>
<p><tt class="docutils literal"><span class="pre">std::string</span></tt> は内部でメモリ確保などの処理が発生するので多用しない。</p>
<p>よい例:</p>
<div class="highlight-none"><div class="highlight"><pre>char database_path[MAX_PATH];
</pre></div>
</div>
<p>悪い例（最大サイズがわかっているのに <tt class="docutils literal"><span class="pre">std::string</span></tt> を使っている）:</p>
<div class="highlight-none"><div class="highlight"><pre>std::string database_path;
</pre></div>
</div>
</div>
<div class="section" id="id7">
<h2>バッファ<a class="headerlink" href="#id7" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>TODO: ちゃんと考える。</p>
<p>何度も繰り返し使う領域（バッファ）が必要な場合は <tt class="docutils literal"><span class="pre">GRN_BULK</span></tt> を使う。例えば、カラムの値を取得する領域などである。</p>
</div>
<div class="section" id="id8">
<h2>命名規則<a class="headerlink" href="#id8" title="このヘッドラインへのパーマリンク">¶</a></h2>
<div class="section" id="id9">
<h3>クラス名<a class="headerlink" href="#id9" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>クラスの名前は <tt class="docutils literal"><span class="pre">UpperCamelCase</span></tt> とする。</p>
<p>よい例:</p>
<div class="highlight-none"><div class="highlight"><pre>class MyClass
{
}
</pre></div>
</div>
<p>悪い例（ <tt class="docutils literal"><span class="pre">snail_case</span></tt> である）:</p>
<div class="highlight-none"><div class="highlight"><pre>class my_class
{
}
</pre></div>
</div>
<p>ただし、 <tt class="docutils literal"><span class="pre">ha_mroonga</span></tt> などMySQLとのインターフェイスとなるクラスでかつ他の類似のモジュールに命名規則がある場合はそれに従う。</p>
<p>よい例:</p>
<div class="highlight-none"><div class="highlight"><pre>class ha_mroonga: public handler
{
}
</pre></div>
</div>
<p>悪い例（ <tt class="docutils literal"><span class="pre">UpperCamelCase</span></tt> になっている）:</p>
<div class="highlight-none"><div class="highlight"><pre>class HaMroonga: public handler
{
}
</pre></div>
</div>
</div>
<div class="section" id="id10">
<h3>メンバー変数名<a class="headerlink" href="#id10" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>メンバー変数名は <tt class="docutils literal"><span class="pre">snail_case</span></tt> とし、末尾にアンダースコア（ <tt class="docutils literal"><span class="pre">_</span></tt> ）を付ける。</p>
<p>よい例:</p>
<div class="highlight-none"><div class="highlight"><pre>class MyClass
{
  char *my_name_;
}
</pre></div>
</div>
<p>悪い例（ <tt class="docutils literal"><span class="pre">UpperCamelCase</span></tt> である）:</p>
<div class="highlight-none"><div class="highlight"><pre>class MyClass
{
  char *MyName_;
}
</pre></div>
</div>
<p>悪い例（末尾にアンダースコアがない）:</p>
<div class="highlight-none"><div class="highlight"><pre>class MyClass
{
  char *my_name;
}
</pre></div>
</div>
</div>
<div class="section" id="id11">
<h3>読み込み用アクセサ名<a class="headerlink" href="#id11" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>メンバー変数の値を読み込むメソッドの名前はメンバー変数名の末尾のアンダースコアを除いたものにする。</p>
<p>よい例:</p>
<div class="highlight-none"><div class="highlight"><pre>class MyClass
{
  char *my_name_;
  const char *my_name() {return my_name_;};
}
</pre></div>
</div>
<p>悪い例（末尾にアンダースコアが残っている）:</p>
<div class="highlight-none"><div class="highlight"><pre>class MyClass
{
  char *my_name_;
  const char *my_name_() {return my_name_;};
}
</pre></div>
</div>
<p>悪い例（先頭に <tt class="docutils literal"><span class="pre">get_</span></tt> を付けている）:</p>
<div class="highlight-none"><div class="highlight"><pre>class MyClass
{
  char *my_name_;
  const char *_my_name() {return my_name_;};
}
</pre></div>
</div>
</div>
<div class="section" id="id12">
<h3>書き込み用アクセサ名<a class="headerlink" href="#id12" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>メンバー変数の値を設定するメソッドの名前は、メンバー変数名の末尾のアンダースコアを除き、先頭に <tt class="docutils literal"><span class="pre">set_</span></tt> を加えたものにする。</p>
<p>よい例:</p>
<div class="highlight-none"><div class="highlight"><pre>class MyClass
{
  unsigned int age_;
  void set_age(unsigned int age)
  {
    age_ = age;
  };
}
</pre></div>
</div>
<p>悪い例（末尾にアンダースコアが残っている）:</p>
<div class="highlight-none"><div class="highlight"><pre>class MyClass
{
  unsigned int age_;
  void set_age_(unsigned int age)
  {
    age_ = age;
  };
}
</pre></div>
</div>
<p>悪い例（先頭に <tt class="docutils literal"><span class="pre">set_</span></tt> ではなく <tt class="docutils literal"><span class="pre">update_</span></tt> を付けている）:</p>
<div class="highlight-none"><div class="highlight"><pre>class MyClass
{
  unsigned int age_;
  void update_age(unsigned int age)
  {
    age_ = age;
  };
}
</pre></div>
</div>
</div>
</div>
<div class="section" id="id13">
<h2>コピーコンストラクター<a class="headerlink" href="#id13" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>基本的にコピーコンストラクターの使用を禁止する。よほどのことがなければ使用しないこと。</p>
<p>コピーコンストラクターは暗黙的に無駄なコピーが発生する可能性があるためパフォーマンス上の問題がある。コピーではなくポインターやリファレンスを用いること。</p>
<p>また、デフォルトのコピーコンストラクター実装はメンバー変数のポインターの値をそのままコピーするため、デコンストラクターで二重に解放してしまう危険性がある。そのため、明示的にコピーコンストラクターを定義しない場合は無効にする。</p>
<p>よい例:</p>
<div class="highlight-none"><div class="highlight"><pre>class MyClass
{
private:
  MyClass(const MyClass &amp;);
}
</pre></div>
</div>
<p>悪い例（コピーコンストラクターを禁止していない）:</p>
<div class="highlight-none"><div class="highlight"><pre>class MyClass
{
}
</pre></div>
</div>
<p>悪い例（カスタムコピーコンストラクターを使っている）:</p>
<div class="highlight-none"><div class="highlight"><pre>class MyClass
{
  unsigned int age_;
  MyClass(const MyClass &amp;object)
  {
    age_ = object.age_;
  }
}
</pre></div>
</div>
</div>
<div class="section" id="id14">
<h2>クラスの代入<a class="headerlink" href="#id14" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>基本的に定義したクラスの代入を禁止する。よほどのことがなければ使用しないこと。</p>
<p>代入演算子は暗黙的に無駄なコピーが発生する可能性があるためパフォーマンス上の問題がある。コピーではなくポインターやリファレンスを用いること。</p>
<p>また、デフォルトの代入演算子の実装はメンバー変数のポインターの値をそのままコピーするため、デコンストラクターで二重に解放してしまう危険性がある。そのため、明示的に代入演算子を定義しない場合は無効にする。</p>
<p>よい例:</p>
<div class="highlight-none"><div class="highlight"><pre>class MyClass
{
private:
  MyClass &amp;operator=(const MyClass &amp;);
}
</pre></div>
</div>
<p>悪い例（代入を禁止していない）:</p>
<div class="highlight-none"><div class="highlight"><pre>class MyClass
{
}
</pre></div>
</div>
<p>悪い例（代入を使っている）:</p>
<div class="highlight-none"><div class="highlight"><pre>class MyClass
{
  unsigned int age_;
  MyClass &amp;operator=(const MyClass &amp;object)
  {
    age_ = object.age_;
    return *this;
  }
}
</pre></div>
</div>
</div>
<div class="section" id="id15">
<h2>引数<a class="headerlink" href="#id15" title="このヘッドラインへのパーマリンク">¶</a></h2>
<div class="section" id="void">
<h3>voidを省略<a class="headerlink" href="#void" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>引数がない場合は <tt class="docutils literal"><span class="pre">void</span></tt> を省略する。</p>
<p>よい例:</p>
<div class="highlight-none"><div class="highlight"><pre>class MyClass
{
  unsigned int age_;
  unsigned int age()
  {
     return age_;
  };
}
</pre></div>
</div>
<p>悪い例（ <tt class="docutils literal"><span class="pre">void</span></tt> を省略していない）:</p>
<div class="highlight-none"><div class="highlight"><pre>class MyClass
{
  unsigned int age_;
  unsigned int age(void)
  {
     return age_;
  };
}
</pre></div>
</div>
</div>
<div class="section" id="const">
<h3>入力用引数にはconstを付ける<a class="headerlink" href="#const" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>入力のみに用いる引数には <tt class="docutils literal"><span class="pre">const</span></tt> を付ける。これは、入力のみに用いる引数である事を明示するためと、間違って引数を変更してしまわないためである。</p>
<p>よい例:</p>
<div class="highlight-none"><div class="highlight"><pre>class Table
{
  void insert(unsigned int id, const char *column_name, const char *value)
  {
     Record *record = records[i];
     Column *column = columns[column_name];
     column.set_value(value);
  }
}
</pre></div>
</div>
<p>悪い例（入力のみに用いているのに <tt class="docutils literal"><span class="pre">const</span></tt> が付いていない）:</p>
<div class="highlight-none"><div class="highlight"><pre>class Table
{
  void insert(unsigned int id, char *column_name, char *value)
  {
     Record *record = records[i];
     Column *column = columns[column_name];
     column.set_value(value);
  }
}
</pre></div>
</div>
</div>
</div>
<div class="section" id="id16">
<h2>定数<a class="headerlink" href="#id16" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>フラグやサイズなどを示す定数には <tt class="docutils literal"><span class="pre">const</span></tt> オブジェクトを用いる。これはデバッガー上でプログラムを走らせているときに名前で値を参照できるようにするためである。</p>
<p>よい例:</p>
<div class="highlight-none"><div class="highlight"><pre>const char *MRN_LOG_FILE_PATH = &quot;groonga.log&quot;;
</pre></div>
</div>
<p>悪い例（ <tt class="docutils literal"><span class="pre">#define</span></tt> を用いている）:</p>
<div class="highlight-none"><div class="highlight"><pre>#define MRN_LOG_FILE_PATH &quot;groonga.log&quot;
</pre></div>
</div>
</div>
<div class="section" id="id17">
<h2>真偽値<a class="headerlink" href="#id17" title="このヘッドラインへのパーマリンク">¶</a></h2>
<div class="section" id="bool">
<h3>bool型を用いる<a class="headerlink" href="#bool" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>真偽値には <tt class="docutils literal"><span class="pre">bool</span></tt> 型を用いる。</p>
<p>よい例:</p>
<div class="highlight-none"><div class="highlight"><pre>bool is_searching;
</pre></div>
</div>
<p>悪い例（ <tt class="docutils literal"><span class="pre">int</span></tt> 型を用いている）:</p>
<div class="highlight-none"><div class="highlight"><pre>int is_searching;
</pre></div>
</div>
</div>
<div class="section" id="true-false">
<h3>真偽値のリテラルには <tt class="docutils literal"><span class="pre">true</span></tt> または <tt class="docutils literal"><span class="pre">false</span></tt> を用いる<a class="headerlink" href="#true-false" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>真偽値の値として <tt class="docutils literal"><span class="pre">true</span></tt> と <tt class="docutils literal"><span class="pre">false</span></tt> はより完結で説明的だからである。</p>
<p>よい例:</p>
<div class="highlight-none"><div class="highlight"><pre>bool is_searching = true;
</pre></div>
</div>
<p>悪い例（ <tt class="docutils literal"><span class="pre">0</span></tt> 以外の値を真の値として用いている）:</p>
<div class="highlight-none"><div class="highlight"><pre>bool is_searching = 1;
</pre></div>
</div>
</div>
</div>
<div class="section" id="id18">
<h2>条件式<a class="headerlink" href="#id18" title="このヘッドラインへのパーマリンク">¶</a></h2>
<div class="section" id="id19">
<h3>真偽値は比較しない<a class="headerlink" href="#id19" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>真偽値の値は <tt class="docutils literal"><span class="pre">boolean_value</span> <span class="pre">==</span> <span class="pre">true</span></tt> などとせず、 <tt class="docutils literal"><span class="pre">boolean_value</span></tt> として条件式に使用する。すでに真偽値の値を真偽値のリテラルと比較することは重複したコードだからである。</p>
<p>よい例:</p>
<div class="highlight-none"><div class="highlight"><pre>boolean is_searching = true;
if (!is_searching) { ... }
</pre></div>
</div>
<p>悪い例（真偽値のリテラルと比較している）:</p>
<div class="highlight-none"><div class="highlight"><pre>boolean is_searching = true;
if (is_searching == false) { ... }
</pre></div>
</div>
</div>
<div class="section" id="null">
<h3><tt class="docutils literal"><span class="pre">NULL</span></tt> と比較しない<a class="headerlink" href="#null" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p><tt class="docutils literal"><span class="pre">NULL</span></tt> かどうかを条件式に使う場合は <tt class="docutils literal"><span class="pre">value</span> <span class="pre">==</span> <span class="pre">NULL</span></tt> ではなく <tt class="docutils literal"><span class="pre">!value</span></tt> というように書く。多くの言語で <tt class="docutils literal"><span class="pre">NULL</span></tt> に相当する値（たとえばLispの <tt class="docutils literal"><span class="pre">nil</span></tt> ）は偽を表すため、明示的に <tt class="docutils literal"><span class="pre">NULL</span></tt> と比較しなくても意図は伝わるからである。</p>
<p>よい例:</p>
<div class="highlight-none"><div class="highlight"><pre>char *name = NULL;
if (!name) { ... }
</pre></div>
</div>
<p>悪い例（ <tt class="docutils literal"><span class="pre">NULL</span></tt> と比較している）:</p>
<div class="highlight-none"><div class="highlight"><pre>char *name = NULL;
if (name == NULL) { ... }
</pre></div>
</div>
</div>
<div class="section" id="id20">
<h3>数値は比較する<a class="headerlink" href="#id20" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>CやC++では <tt class="docutils literal"><span class="pre">0</span></tt> は偽、 <tt class="docutils literal"><span class="pre">0</span></tt> 以外は真の値となるが、条件式に数値を使う場合は <tt class="docutils literal"><span class="pre">strcmp(...)</span> <span class="pre">==</span> <span class="pre">0</span></tt> などというように明示的に比較する。</p>
<p>C++では真偽値に <tt class="docutils literal"><span class="pre">bool</span></tt> を使うためこのような状況は発生しないが、C言語由来のAPIでは <tt class="docutils literal"><span class="pre">int</span></tt> で真偽値を表現している場合が多い。しかし、 <tt class="docutils literal"><span class="pre">int</span></tt> だけでは真偽値として使っているか本当に数値として使っているかがわかりにくいため、 <tt class="docutils literal"><span class="pre">int</span></tt> のときはすべて数値として扱う。</p>
<p>よい例:</p>
<div class="highlight-none"><div class="highlight"><pre>if (memcmp(value1, value2, value_size) == 0) {
  printf(&quot;same value!\n&quot;);
}
</pre></div>
</div>
<p>悪い例（ <tt class="docutils literal"><span class="pre">0</span></tt> を偽の値として扱っている）:</p>
<div class="highlight-none"><div class="highlight"><pre>if (!memcmp(value1, value2, value_size)) {
  printf(&quot;same value!\n&quot;);
}
</pre></div>
</div>
</div>
</div>
<div class="section" id="id21">
<h2>初期化<a class="headerlink" href="#id21" title="このヘッドラインへのパーマリンク">¶</a></h2>
<div class="section" id="id22">
<h3>メンバー変数の初期化には初期化リストを用いる<a class="headerlink" href="#id22" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>無駄な処理を省くためにコンストラクターでのメンバー変数の初期化には初期化リストを用いる。初期化リストを用いないとコンストラクターの処理とコピーコンストラクター・代入処理が行われたりなど非効率である。（後述）</p>
<p>よい例:</p>
<div class="highlight-none"><div class="highlight"><pre>class Table
{
  Table(const char *name);
  std::string name_;
}

Table::Table(const char *name) :
  name_(name)
{
}
</pre></div>
</div>
<p>悪い例（ <tt class="docutils literal"><span class="pre">std::string(name)</span></tt> のところでコンストラクターが動き、 <tt class="docutils literal"><span class="pre">name_</span> <span class="pre">=</span> <span class="pre">...</span></tt> のところで代入演算子が動いて2回初期化している）:</p>
<div class="highlight-none"><div class="highlight"><pre>class Table
{
  Table(const char *name);
  std::string name_;
}

Table::Table(const char *name)
{
  name_ = std::string(name);
}
</pre></div>
</div>
</div>
<div class="section" id="id23">
<h3>変数宣言と同時に初期化する<a class="headerlink" href="#id23" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>変数を宣言したときに同時に初期化する。宣言時に初期化せずに代入して初期化すると、無駄な処理が発生する可能性があるため非効率である。（後述）</p>
<p>よい例:</p>
<div class="highlight-none"><div class="highlight"><pre>std::string name(&quot;users&quot;);
</pre></div>
</div>
<p>悪い例（ <tt class="docutils literal"><span class="pre">std::string()</span></tt> のところでコンストラクターが動き、 <tt class="docutils literal"><span class="pre">name</span> <span class="pre">=</span> <span class="pre">...</span></tt> のところで代入演算子が動いて2回初期化している）:</p>
<div class="highlight-none"><div class="highlight"><pre>std::string name;
name = std::string(&quot;users&quot;);
</pre></div>
</div>
</div>
</div>
<div class="section" id="id24">
<h2>インクリメント・デクリメント<a class="headerlink" href="#id24" title="このヘッドラインへのパーマリンク">¶</a></h2>
<div class="section" id="id25">
<h3>前置形式を用いる<a class="headerlink" href="#id25" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>後置形式ではオブジェクトのコピーをしなければいけないため非効率である。そのため、できるだけ前置形式を用いる。</p>
<p>よい例（ <tt class="docutils literal"><span class="pre">int</span></tt> だと効率は変わらないので本当はあんまりよい例ではない）:</p>
<div class="highlight-none"><div class="highlight"><pre>for (int i = 0; i &lt; 10; ++i) {
}
</pre></div>
</div>
<p>悪い例（後置形式を用いている）:</p>
<div class="highlight-none"><div class="highlight"><pre>for (int i = 0; i &lt; 10; ++i) {
}
</pre></div>
</div>
</div>
</div>
<div class="section" id="id26">
<h2>キャスト<a class="headerlink" href="#id26" title="このヘッドラインへのパーマリンク">¶</a></h2>
<div class="section" id="c">
<h3>C++のスタイルを用いる<a class="headerlink" href="#c" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>Cスタイルのキャストはなんでもキャストできてしまうため、意図しないキャストにも気付かない可能性がある。例えば、単に <tt class="docutils literal"><span class="pre">const</span></tt> を外したいだけなのに、間違って違う型に変換していても気付けない。C++のキャストでは <tt class="docutils literal"><span class="pre">const</span></tt> を外したいときは <tt class="docutils literal"><span class="pre">const_cast</span></tt> を使用し、型を変換するときは <tt class="docutils literal"><span class="pre">static_cast</span></tt> を指定する。こうすれば、 <tt class="docutils literal"><span class="pre">static_cast</span></tt> で間違って <tt class="docutils literal"><span class="pre">const</span></tt> を外してしまっている場合も気付ける。 <tt class="docutils literal"><span class="pre">reinterpret_cast</span></tt> はどうしても必要なときのみ注意して使う。</p>
<p>よい例（ <tt class="docutils literal"><span class="pre">const_cast</span></tt> を使っている）:</p>
<div class="highlight-none"><div class="highlight"><pre>uchar *to_key;
const ucahr *from_key;
KEY *key_info;
uint key_length;
key_copy(to_key, const_cast&lt;uchar *&gt;from_key, key_info, key_length);
</pre></div>
</div>
<p>よい例（ <tt class="docutils literal"><span class="pre">static_cast</span></tt> を使っている）:</p>
<div class="highlight-none"><div class="highlight"><pre>int n_hits = 1;
int n_documents = 10;
float hit_ratio = (float)(n_hits) / n_documents;
</pre></div>
</div>
<p>よい例（ <tt class="docutils literal"><span class="pre">static_cast</span></tt> では無理なので <tt class="docutils literal"><span class="pre">reinterpret_cast</span></tt> を使っている）:</p>
<div class="highlight-none"><div class="highlight"><pre>THD *thread = current_thd;
my_hash_delete(&amp;mrn_allocated_thds, reinterpret_cast&lt;uchar *&gt;(thread));
</pre></div>
</div>
<p>悪い例（Cスタイルのキャストを使っている）:</p>
<div class="highlight-none"><div class="highlight"><pre>int n_hits = 1;
int n_documents = 10;
float hit_ratio = (float)(n_hits) / n_documents;
</pre></div>
</div>
<p>悪い例（ <tt class="docutils literal"><span class="pre">static_cast</span></tt> で十分なのに <tt class="docutils literal"><span class="pre">reinterpret_cast</span></tt> を使っている）:</p>
<div class="highlight-none"><div class="highlight"><pre>void *value = get_value(key);
char *name;
name = reinterpret_cast&lt;char *&gt;(value);
</pre></div>
</div>
</div>
</div>
<div class="section" id="id27">
<h2>変数宣言<a class="headerlink" href="#id27" title="このヘッドラインへのパーマリンク">¶</a></h2>
<div class="section" id="id28">
<h3>ポインタ型を示す <tt class="docutils literal"><span class="pre">*</span></tt> とリファレンス型を示す <tt class="docutils literal"><span class="pre">&amp;</span></tt> は変数名に寄せる<a class="headerlink" href="#id28" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>Cと同様にポインタ型を示す <tt class="docutils literal"><span class="pre">*</span></tt> は型名ではなく変数名に寄せる。これは、以下のように複数の変数を一度に宣言したときに一貫性がなくなるためである。2つめ以降の変数は近くに型名がないため <tt class="docutils literal"><span class="pre">*</span></tt> を寄せる場所がない。</p>
<p>例:</p>
<div class="highlight-none"><div class="highlight"><pre>char* key, *value;
</pre></div>
</div>
<p>同様に、リファレンス型を示す <tt class="docutils literal"><span class="pre">&amp;</span></tt> も変数名に寄せる。</p>
<p>なお、 <tt class="docutils literal"><span class="pre">*</span></tt> や <tt class="docutils literal"><span class="pre">&amp;</span></tt> と型名の間にはスペースを入れない。</p>
<p>よい例:</p>
<div class="highlight-none"><div class="highlight"><pre>char *key;
</pre></div>
</div>
<p>よい例:</p>
<div class="highlight-none"><div class="highlight"><pre>bool is_exist(const std::string &amp;file_name);
</pre></div>
</div>
<p>悪い例（型名に寄せている）:</p>
<div class="highlight-none"><div class="highlight"><pre>char* key;
</pre></div>
</div>
</div>
</div>
<div class="section" id="id29">
<h2>その他<a class="headerlink" href="#id29" title="このヘッドラインへのパーマリンク">¶</a></h2>
<blockquote>
<div><ul class="simple">
<li>ここに書いていないものについては特にスタイルを定めないが、
プロジェクト内で常に一貫性のあるスタイルを使用すること。
同じような事をするときは同じような書き方にすること。
複数の書き方で同じようなことを実現している場合は1つの方法に合わせること。</li>
</ul>
</div></blockquote>
<p>以下、具体例が必要。</p>
<blockquote>
<div><ul>
<li><p class="first">ビルド時にできることを実行時に延ばさない(静的チェックを活用)</p>
</li>
<li><p class="first">なるべく局所的に変数を定義し、同時に初期化する</p>
</li>
<li><p class="first">長い関数や深いブロックのネストを避ける
* 2つに分けた方がよさそう。あと目安があるといいかも。</p>
<blockquote>
<div><p>100行以上は長いよねーとか3段以上はデンジャーとか。</p>
</div></blockquote>
</li>
<li><p class="first">必要以上にオブジェクトを複製しない</p>
</li>
<li><p class="first">暗黙の型変換はなるべく避ける</p>
</li>
<li><p class="first">assertを積極的に使う</p>
</li>
</ul>
</div></blockquote>
</div>
<div class="section" id="id30">
<h2>メモ<a class="headerlink" href="#id30" title="このヘッドラインへのパーマリンク">¶</a></h2>
<blockquote>
<div><ul class="simple">
<li>動的テンプレートを使わない。（要追加情報。implicit
template instantiationのことであれば、これはふつうに使わ
れているものなので特に禁止しないんでいいんじゃない説？）</li>
<li>typeidを使わない。</li>
<li>例外はMySQLで問題がないようであればOK。mroongaから外の世
界（MySQLの世界）にはださないようにする。</li>
</ul>
</div></blockquote>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../index.html">目次</a></h3>
  <ul>
<li><a class="reference internal" href="#">コーディングスタイル</a><ul>
<li><a class="reference internal" href="#id2">言語</a></li>
<li><a class="reference internal" href="#id3">ファイル名</a></li>
<li><a class="reference internal" href="#id4">名前空間</a></li>
<li><a class="reference internal" href="#include"><tt class="docutils literal"><span class="pre">include</span></tt> ガード</a></li>
<li><a class="reference internal" href="#id5">代入</a></li>
<li><a class="reference internal" href="#id6">文字列</a></li>
<li><a class="reference internal" href="#id7">バッファ</a></li>
<li><a class="reference internal" href="#id8">命名規則</a><ul>
<li><a class="reference internal" href="#id9">クラス名</a></li>
<li><a class="reference internal" href="#id10">メンバー変数名</a></li>
<li><a class="reference internal" href="#id11">読み込み用アクセサ名</a></li>
<li><a class="reference internal" href="#id12">書き込み用アクセサ名</a></li>
</ul>
</li>
<li><a class="reference internal" href="#id13">コピーコンストラクター</a></li>
<li><a class="reference internal" href="#id14">クラスの代入</a></li>
<li><a class="reference internal" href="#id15">引数</a><ul>
<li><a class="reference internal" href="#void">voidを省略</a></li>
<li><a class="reference internal" href="#const">入力用引数にはconstを付ける</a></li>
</ul>
</li>
<li><a class="reference internal" href="#id16">定数</a></li>
<li><a class="reference internal" href="#id17">真偽値</a><ul>
<li><a class="reference internal" href="#bool">bool型を用いる</a></li>
<li><a class="reference internal" href="#true-false">真偽値のリテラルには <tt class="docutils literal"><span class="pre">true</span></tt> または <tt class="docutils literal"><span class="pre">false</span></tt> を用いる</a></li>
</ul>
</li>
<li><a class="reference internal" href="#id18">条件式</a><ul>
<li><a class="reference internal" href="#id19">真偽値は比較しない</a></li>
<li><a class="reference internal" href="#null"><tt class="docutils literal"><span class="pre">NULL</span></tt> と比較しない</a></li>
<li><a class="reference internal" href="#id20">数値は比較する</a></li>
</ul>
</li>
<li><a class="reference internal" href="#id21">初期化</a><ul>
<li><a class="reference internal" href="#id22">メンバー変数の初期化には初期化リストを用いる</a></li>
<li><a class="reference internal" href="#id23">変数宣言と同時に初期化する</a></li>
</ul>
</li>
<li><a class="reference internal" href="#id24">インクリメント・デクリメント</a><ul>
<li><a class="reference internal" href="#id25">前置形式を用いる</a></li>
</ul>
</li>
<li><a class="reference internal" href="#id26">キャスト</a><ul>
<li><a class="reference internal" href="#c">C++のスタイルを用いる</a></li>
</ul>
</li>
<li><a class="reference internal" href="#id27">変数宣言</a><ul>
<li><a class="reference internal" href="#id28">ポインタ型を示す <tt class="docutils literal"><span class="pre">*</span></tt> とリファレンス型を示す <tt class="docutils literal"><span class="pre">&amp;</span></tt> は変数名に寄せる</a></li>
</ul>
</li>
<li><a class="reference internal" href="#id29">その他</a></li>
<li><a class="reference internal" href="#id30">メモ</a></li>
</ul>
</li>
</ul>

  <h3>このページ</h3>
  <ul class="this-page-menu">
    <li><a href="../sources/developer/coding_style.txt"
           rel="nofollow">ソースコードを表示</a></li>
  </ul>
<div id="searchbox" style="display: none">
  <h3>クイック検索</h3>
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="検索" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    モジュール、クラス、または関数名を入力してください
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>ナビゲーション</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="総合索引"
             >索引</a></li>
        <li><a href="../index.html">mroonga v3.02 documentation</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2009-2013, mroonga project.
    </div>
      <script src="http://connect.facebook.net/ja_JP/all.js"></script>

    <script>
      FB.init({
         appId  : null,
         status : true, // check login status
         cookie : true, // enable cookies to allow the server to access the session
         xfbml  : true  // parse XFBML
      });
    </script>
  </body>

</html>
